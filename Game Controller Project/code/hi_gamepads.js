autowatch = 1;
outlets = 4; //pattrstorage name and value, note on/off, available parameters
setoutletassist(0,'pattrstorage name and value');
setoutletassist(1,'note number and velocity');
setoutletassist(2,'long names of parameters');
setoutletassist(3,'errors and warnings');

var midiout = 1;
var controllername = '';
var maxvel = 120;
var useimu = 1;

//ideally this could be generated by reading in all profile files and getting the main key, but for now this is hardcoded
var profiles = {
	"Logitech Dual Action":"logitech-dual-action_mac12_prof.json",
	"Logitech Dual Action _1":"logitech-dual-action_mac10_prof.json",
	"Logitech Dual Action _2":"logitech-dual-action_win11_prof.json",
	"Sensel Morph":"sensel-morph_mac12_prof.json",
	"Sensel Morph _1":"sensel-morph_win11_prof.json",
	"PLAYSTATION(R)3 Controller":"sony-ps3-six-axis_mac12_prof.json",
	"PLAYSTATION(R)3 Controller _1":"sony-ps3-six-axis_mac10_prof.json"
}
//setup the specifics for different brands of controllers.
var game = {};

//the indices for LDA for macOS 12 and up
game["Logitech Dual Action"] = {

		"13": {
			"map": "RT",
			"range": [0, 10]
		},
		"11": {
			"map": "RB",
			"range": [0, 10]
		},
		"12": {
			"map": "LT",
			"range": [0, 10]
		},
		"10": {
			"map": "LB",
			"range": [0, 10]
		},
		"23": {
			"map": "dpad_C",
			"range": [0, 10]
		},
		"14": {
			"map": "back",
			"range": [0, 10]
		},
		"15": {
			"map": "start",
			"range": [0, 10]
		},
		"16": {
			"map": "jsb_L",
			"range": [0, 10]
		},
		"17": {
			"map": "jsb_R",
			"range": [0, 10]
		},
		"9": {
			"map": "col_U",
			"range": [0, 10]
		},
		"6": {
			"map": "col_L",
			"range": [0, 10]
		},
		"8": {
			"map": "col_R",
			"range": [0, 10]
		},
		"7": {
			"map": "col_D",
			"range": [0, 10]
		},
		"19": {
			"map": "js_L_X",
			"range": [0, 10]
		},
		"20": {
			"map": "js_L_Y",
			"range": [0, 10]
		},
		"21": {
			"map": "js_R_X",
			"range": [0, 10]
		},
		"22": {
			"map": "js_R_Y",
			"range": [0, 10]
		}
	}

game.longnames = {
	'RT':'Right Trigger',
	'RB':'Right Bumper',
	'LT':'Left Trigger',
	'LB':'Left Bumper',
	'dpad_L':'Dpad Left',
	'dpad_U':'Dpad Up',
	'dpad_R':'Dpad Right',
	'dpad_D':'Dpad Down',
	'dpad_C':'Dpad Composite',
	'back':'Back',
	'start':'Start',
	'jsb_L':'Joystick Button Left',
	'jsb_R':'Joystick Button Right',
	'col_U':'Color Button Up',
	'col_L':'Color Button Left',
	'col_R':'Color Button Right',
	'col_D':'Color Button Down',
	'js_L_X':'Joystick Left X',
	'js_L_Y':'Joystick Left Y',
	'js_R_X':'Joystick Right X',
	'js_R_Y':'Joystick Right Y',
	'LB_press':'Left Bumper Pressure',
	'LT_press':'Left Trigger Pressure',
	'RB_press':'Right Bumper Pressure',
	'RT_press':'Right Trigger Pressure',
	'dpad_L_press':'Dpad Left Pressure',
	'dpad_U_press':'Dpad Up Pressure',
	'dpad_R_press':'Dpad Right Pressure',
	'dpad_D_press':'Dpad Down Pressure',
	'col_U_press':'Color Button Up Pressure',
	'col_L_press':'Color Button Left Pressure',
	'col_R_press':'Color Button Right Pressure',
	'col_D_press':'Color Button Down Pressure',
	'yaw':'Yaw (circa Z)',
	'pitch':'Pitch (circa Y)',
	'roll':'Roll (circa X)',
	'unk':'Unknown',
	'yaw_v':'Yaw Acceleration',
	'pitch_v':'Pitch Acceleration',
	'roll_v':'Roll Acceleration',
	'unk_v':'Unknown Acceleration',
	'notsure':'???'
}

function imu(v){
	post('\nuse imu '+v);
	useimu = v;
}

function simplename(s){
	if(s=='ps3'){
		ctls('PLAYSTATION(R)3 Controller');
	}
	if(s=='logitech'){
		ctls('Logitech Dual Action');
	}
	if(s=='logitech_1'){
		ctls('Logitech Dual Action 1');
	}
}

function variant(v){
	outlet(3,"off");
	//initial value is empty
	if(controllername != ''){
		//get the last part of the controller name. we are looking for things like "_2"
		var namelist = controllername.split(' ');
		var end = namelist[namelist.length-1];
		var last = end.split("_"); //variations end with _1, _2, _3
		var varindex = parseInt(last[1]);
		post("\ncurrent controller name: "+controllername);
		post("\n last: "+end);
		post("\n int: "+last+" ? "+isNaN(last) );
		//need to modify controller name
		if(isNaN(varindex)){
			//current controller is main map, no appendage
			if(v>0){
				//add the _<variant number> like _2
				controllername = controllername+" _"+v;
			} else {
				controllername = namelist.join(' '); //do I really need to put it back together?
			}
		} else {
			//modify the controllername by appending new variant number and redefine maps to variant
			namelist.pop(); //ditch the last word
			if(v>0){
				//add the _<variant number> like _2
				controllername = namelist.join(' ')+" _"+v;
			} else {
				controllername = namelist.join(' ');
			}
		}
		post("\nnew profile key: "+controllername);
		var pfile = profiles[controllername];
		if(pfile){
			importprofile(pfile);
		} else {
			errors("no profile found");
		}
		// if(game[controllername]){
		// 	post("\nusing profile "+controllername);
		// 	ctls(controllername);
		// }else{
		// 	errors("no map at this variation");
		// }
	} else {
		errors("select a game controller first");
	}

}

function errors(s){
	post(s+"\n");
	outlet(3,s);
}

//use a dict in the patch to access the ranges of controls when selected in menu
var gcranges = new Dict('gamecontroller_ranges');
//set up game controller with mappings and ranges from profiles
function ctls(s){
	gcranges.clear();
	controllername = s;
	var pfile = profiles[controllername];
	post("\n profile key: "+controllername+" and name "+pfile);
	if(pfile){
		importprofile(pfile);
	} else {
		errors("no profile found");
	}

	if(game[controllername]){
		for (i in game[controllername]){
			var item = game[controllername][i].map;
			var readable = game.longnames[item];
			var range = game[controllername][i].range;
			post("--ctls: "+i+" "+readable+" "+range+"\n");
			gcranges.set(item,range);
			outlet(2,readable,range);
		}
	} else {
		errors("no profile for this game controller");
	}
	//post('\nusing: '+controllername);
}

var last_dpad = '';
var exclmidi = new Dict('exclude_midi');
function list()
{
	var a = arrayfromargs(arguments);
	var cindex = a[0];
	var index = cindex.toString();
	var value = a[1];
	//post('\nin: '+cindex);

	switch(controllername){
		//two cases in a row is like an "OR" statement. neat!
 		case 'Logitech Dual Action':
 		case 'Logitech Dual Action _1':
			var outname = game[controllername][index].map;
			var rangevec = game[controllername][index].range;
			var range = Math.abs(rangevec[1]-rangevec[0]);
			var nomidi = exclmidi.get(outname); //should be 1 if exists
			// post('\nuse midi for this? '+outname+" "+nomidi);
			//this controller uses a single index for the Dpad, with different values for each direction.
			if(outname == 'dpad_C'){
				var dpaddirs = {
					'0':'dpad_U',
					'1':'dpad_ne',
					'2':'dpad_R',
					'3':'dpad_se',
					'4':'dpad_D',
					'5':'dpad_sw',
					'6':'dpad_L',
					'7':'dpad_nw',
					'8':'dpad_off',
				};
				//value from dpad press indicates its direction, eg (23,1) is right dpad
				outname = dpaddirs[value.toString()];
				//this is kind of a brute force method to turn off all dpad presses. using the last_dpad didnt' work well with the diagonals.
				if(outname=='dpad_off'){
					for(outn in dpaddirs){
						//these are all buttons, so send out noteoff (note number, value) pairs
						// if(midiout && nomidi!=1){
						// 	post("dpad notes: "+outn+" "+noteval+"\n");
						// 	noteval = parseInt(outn)+36;
						// 	outlet(1,noteval,0);
						// }
						//better than the above commented out code is to just use Max's 'flush' object to turn notes off
						outlet(1,"bang");
						outlet(0,dpaddirs[outn],0);
					}
				} else {
					//see if we need to send out note/value pairs
					if(range == 1 && (midiout && nomidi!=1) ){
						noteval = parseInt(value)+36;
						// post("dpad notes: "+value+" "+noteval+"\n");
						outlet(1,noteval,maxvel)
					}
					last_dpad = outname;
					outlet(0,outname,1);

				}
				// post('\noutname dpad: '+outname+' '+value);
			//if the outname is not dpad_C we can just sed out the data
			} else {
				// post('\noutname other: '+outname+' '+value);
				//see if we need to send out note/value pairs
				if(range == 1 && (midiout && nomidi!=1) ){
					noteval = cindex+36;
					outlet(1,noteval,value*maxvel)
				}
				outlet(0,outname,value);
			}
		break;

		case 'Sensel Morph':
			var outname = game[controllername][index].map;
			var range = game[controllername][index].range;
			//post('\noutname: '+cindex+' - '+outname);
			//see if we need to send out note/value pairs
			if(range == 1){
				noteval = cindex+36;
				outlet(1,noteval,value*maxvel)
			}
			outlet(0,outname,value);
		break;

		case 'PLAYSTATION(R)3 Controller':
		case 'PLAYSTATION(R)3 Controller _1':
			var outname = game[controllername][index].map;
			var range = game[controllername][index].range;
			//post('\noutname: '+cindex+' - '+outname);
			//need to adjust for variant 0, as "30" is only for variant 1
			var isimu = (cindex>60 || cindex===30);

			if(useimu>0){
				//see if we need to send out note/value pairs
				if(range == 1){
					noteval = cindex+36;
					outlet(1,noteval,value*maxvel)
				}
				outlet(0,outname,value);
			}else{
				//suppress acceleromo
				if(!isimu){
					//see if we need to send out note/value pairs
					if(range == 1){
						noteval = cindex+36;
						outlet(1,noteval,value*maxvel)
					}
					outlet(0,outname,value);
				}
			}
		break;

		case 'default':

		break;

	}
}

function importprofile(profileFile){
	var g = new Dict;
	var gname = '';
	//check if file exists
	var isfile = checkForFile(profileFile);
	if(isfile){
		g.import_json(profileFile);
		var gameprofile = JSON.parse(g.stringify());
		for(i in gameprofile){
			gname = i;
			post("\nprofile for: "+i);
		}
		//add to our profiles
		game[gname]=gameprofile[gname];
	} else {
		//nothing happens
	}
}

function checkForFile(fileName) //check to see if file exists
{
	var s = fileName;
	f = new File(s, "read");
	if (f.isopen) //if succeed in opening file
	{
		f.close();
		post("\nfile found: " + fileName + "\n");
		return (true);
	}
	else //file doesn't exist
	{
		f.close(); //anal retentively close file
		errors("file not found: " + fileName);
		return (false);
	}
}
